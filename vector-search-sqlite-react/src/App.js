import './App.css';
import React from 'react';
import { tableFromIPC } from 'apache-arrow';
import codebk from './codewords.json';
import { pipeline } from '@xenova/transformers';
import * as ort from 'onnxruntime-web';
import RangeSlider from 'react-bootstrap-range-slider';
import millify from 'millify';

const InferenceSession = ort.InferenceSession;
const Tensor = ort.Tensor;

// Add either `filterZero` or `filterShim` to `input`, based on whether the value of `filterColumn` is `filterValue`
const filteredtopkasc = Uint8Array.from([
  0x08, 0x08, 0x12, 0x07, 0x70, 0x79, 0x74, 0x6f, 0x72, 0x63, 0x68, 0x1a, 0x05, 0x32, 0x2e, 0x31, 0x2e, 0x30, 0x3a, 0xde, 0x05, 0x0a, 0x3b, 0x0a, 0x0c, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43,
  0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0f, 0x2f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75,
  0x74, 0x5f, 0x30, 0x1a, 0x06, 0x2f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x22, 0x05, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x0a, 0x49, 0x0a, 0x0f, 0x2f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x5f, 0x6f, 0x75, 0x74,
  0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5a, 0x65, 0x72, 0x6f, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x68, 0x69, 0x6d, 0x12, 0x0f, 0x2f,
  0x57, 0x68, 0x65, 0x72, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x06, 0x2f, 0x57, 0x68, 0x65, 0x72, 0x65, 0x22, 0x05, 0x57, 0x68, 0x65, 0x72, 0x65, 0x0a, 0x32, 0x0a,
  0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x0a, 0x0f, 0x2f, 0x57, 0x68, 0x65, 0x72, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0d, 0x2f, 0x41, 0x64, 0x64, 0x5f, 0x6f, 0x75,
  0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x04, 0x2f, 0x41, 0x64, 0x64, 0x22, 0x03, 0x41, 0x64, 0x64, 0x0a, 0x45, 0x12, 0x12, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x6f,
  0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x09, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a, 0x0a, 0x05,
  0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x4f, 0x0a, 0x01, 0x6b, 0x0a, 0x12, 0x2f,
  0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70,
  0x75, 0x74, 0x5f, 0x30, 0x1a, 0x08, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x22, 0x07, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x2a, 0x10, 0x0a, 0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
  0x7a, 0x65, 0x72, 0x6f, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x0a, 0x3b, 0x0a, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0e,
  0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x05, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x22, 0x04, 0x43, 0x61, 0x73, 0x74, 0x2a, 0x09, 0x0a, 0x02, 0x74,
  0x6f, 0x18, 0x07, 0xa0, 0x01, 0x02, 0x0a, 0x79, 0x0a, 0x0d, 0x2f, 0x41, 0x64, 0x64, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x0e, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f,
  0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0e, 0x2f, 0x54, 0x6f, 0x70, 0x4b, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x1a,
  0x05, 0x2f, 0x54, 0x6f, 0x70, 0x4b, 0x22, 0x04, 0x54, 0x6f, 0x70, 0x4b, 0x2a, 0x14, 0x0a, 0x04, 0x61, 0x78, 0x69, 0x73, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xa0,
  0x01, 0x02, 0x2a, 0x0e, 0x0a, 0x07, 0x6c, 0x61, 0x72, 0x67, 0x65, 0x73, 0x74, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x2a, 0x0d, 0x0a, 0x06, 0x73, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x18, 0x01, 0xa0, 0x01,
  0x02, 0x12, 0x09, 0x74, 0x6f, 0x72, 0x63, 0x68, 0x5f, 0x6a, 0x69, 0x74, 0x5a, 0x1b, 0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x12, 0x0a, 0x10, 0x08, 0x01, 0x12, 0x0c, 0x0a, 0x0a, 0x12,
  0x08, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6c, 0x65, 0x6e, 0x5a, 0x22, 0x0a, 0x0c, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x12, 0x0a, 0x10, 0x08, 0x01, 0x12,
  0x0c, 0x0a, 0x0a, 0x12, 0x08, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6c, 0x65, 0x6e, 0x5a, 0x19, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0a, 0x0a, 0x08,
  0x08, 0x01, 0x12, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x5a, 0x18, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5a, 0x65, 0x72, 0x6f, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x01, 0x12, 0x04, 0x0a, 0x02,
  0x08, 0x01, 0x5a, 0x18, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x68, 0x69, 0x6d, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x01, 0x12, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x5a, 0x0f, 0x0a, 0x01,
  0x6b, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x02, 0x12, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x62, 0x24, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x1a, 0x0a, 0x18, 0x08, 0x07, 0x12, 0x14, 0x0a,
  0x12, 0x12, 0x10, 0x54, 0x6f, 0x70, 0x4b, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x6d, 0x5f, 0x30, 0x42, 0x02, 0x10, 0x10

]);

// this is handmade ONNX using GatherElements from a much less efficient PyTorch model. The dimensions for PQ48x7 quantizing a 384-dimensional embedding is baked in.
// thanks, https://github.com/ZhangGe6/onnx-modifier
const pqdist = Uint8Array.from([
  0x08, 0x08, 0x12, 0x07, 0x70, 0x79, 0x74, 0x6f, 0x72, 0x63, 0x68, 0x1a, 0x05, 0x32, 0x2e, 0x31, 0x2e, 0x30, 0x3a, 0xe3, 0x0c, 0x0a, 0x55, 0x12, 0x12, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61,
  0x6e, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x09, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74,
  0x2a, 0x2a, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x1e, 0x08, 0x03, 0x10, 0x07, 0x4a, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x53, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x0a, 0x12, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74,
  0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x08, 0x2f, 0x52,
  0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x22, 0x07, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x2a, 0x10, 0x0a, 0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x7a, 0x65, 0x72, 0x6f, 0x18, 0x00, 0xa0, 0x01,
  0x02, 0x0a, 0x37, 0x0a, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x0a, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30,
  0x12, 0x0d, 0x2f, 0x53, 0x75, 0x62, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x04, 0x2f, 0x53, 0x75, 0x62, 0x22, 0x03, 0x53, 0x75, 0x62, 0x0a, 0x29, 0x0a, 0x0d, 0x2f, 0x53,
  0x75, 0x62, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0d, 0x2f, 0x41, 0x62, 0x73, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x04, 0x2f, 0x41, 0x62, 0x73,
  0x22, 0x03, 0x41, 0x62, 0x73, 0x0a, 0x43, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x0b, 0x2f,
  0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x08, 0x10,
  0x01, 0x4a, 0x04, 0x00, 0x00, 0x00, 0x40, 0xa0, 0x01, 0x04, 0x0a, 0x3f, 0x0a, 0x0d, 0x2f, 0x41, 0x62, 0x73, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x14, 0x2f, 0x43, 0x6f,
  0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0d, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30,
  0x1a, 0x04, 0x2f, 0x50, 0x6f, 0x77, 0x22, 0x03, 0x50, 0x6f, 0x77, 0x0a, 0x49, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x32, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75,
  0x74, 0x5f, 0x30, 0x1a, 0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x32, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a, 0x0a, 0x05, 0x76, 0x61,
  0x6c, 0x75, 0x65, 0x2a, 0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x7f, 0x0a, 0x0d, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x6f,
  0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x32, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x13, 0x2f,
  0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x0a, 0x2f, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x22, 0x09,
  0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x2a, 0x0f, 0x0a, 0x08, 0x6b, 0x65, 0x65, 0x70, 0x64, 0x69, 0x6d, 0x73, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x2a, 0x1b, 0x0a, 0x14, 0x6e, 0x6f,
  0x6f, 0x70, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x61, 0x78, 0x65, 0x73, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x0a, 0x43, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73,
  0x74, 0x61, 0x6e, 0x74, 0x5f, 0x33, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x33, 0x22, 0x08, 0x43, 0x6f,
  0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x08, 0x10, 0x01, 0x4a, 0x04, 0x00, 0x00, 0x00, 0x3f, 0xa0, 0x01, 0x04, 0x0a, 0x49, 0x0a, 0x13,
  0x2f, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x33,
  0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0f, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x31, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x06, 0x2f, 0x50, 0x6f, 0x77,
  0x5f, 0x31, 0x22, 0x03, 0x50, 0x6f, 0x77, 0x0a, 0x49, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x34, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a,
  0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x34, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a,
  0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0x01, 0x04, 0x0a, 0x34, 0x0a, 0x0a, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x73,
  0x12, 0x0e, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x05, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x22, 0x04, 0x43, 0x61, 0x73, 0x74, 0x2a, 0x09, 0x0a,
  0x02, 0x74, 0x6f, 0x18, 0x06, 0xa0, 0x01, 0x02, 0x0a, 0x86, 0x02, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x35, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f,
  0x30, 0x1a, 0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x35, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0xd6, 0x01, 0x0a, 0x05, 0x76, 0x61, 0x6c,
  0x75, 0x65, 0x2a, 0xc9, 0x01, 0x08, 0x01, 0x08, 0x30, 0x10, 0x06, 0x4a, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x80, 0x05, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x00, 0x80, 0x06, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x80, 0x09, 0x00, 0x00, 0x00, 0x0a,
  0x00, 0x00, 0x80, 0x0a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x80, 0x0b, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x80, 0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x80, 0x0d, 0x00, 0x00, 0x00, 0x0e,
  0x00, 0x00, 0x80, 0x0e, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00, 0x12,
  0x00, 0x00, 0x80, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x80, 0x14, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x80, 0x15, 0x00, 0x00, 0x00, 0x16,
  0x00, 0x00, 0x80, 0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x80, 0x17, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x47, 0x12, 0x12, 0x6f, 0x6e, 0x6e, 0x78, 0x3a, 0x3a, 0x52, 0x65, 0x64, 0x75, 0x63,
  0x65, 0x53, 0x75, 0x6d, 0x5f, 0x32, 0x31, 0x1a, 0x0b, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x36, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a,
  0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x57, 0x0a, 0x0f, 0x63, 0x75,
  0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x34, 0x0a, 0x12, 0x6f, 0x6e, 0x6e, 0x78, 0x3a, 0x3a, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x32,
  0x31, 0x12, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x1a, 0x0c, 0x2f, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x31, 0x22, 0x09, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53,
  0x75, 0x6d, 0x2a, 0x0f, 0x0a, 0x08, 0x6b, 0x65, 0x65, 0x70, 0x64, 0x69, 0x6d, 0x73, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x0a, 0x46, 0x0a, 0x0f, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x31, 0x5f, 0x6f, 0x75,
  0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0f, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x31, 0x1a, 0x17, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f,
  0x61, 0x64, 0x64, 0x65, 0x64, 0x5f, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x73, 0x65, 0x30, 0x22, 0x09, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x73, 0x65, 0x0a, 0x60, 0x0a, 0x0f, 0x63,
  0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x31, 0x0a, 0x0e, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0f,
  0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x34, 0x1a, 0x1c, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x61, 0x64, 0x64, 0x65, 0x64, 0x5f, 0x47, 0x61,
  0x74, 0x68, 0x65, 0x72, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x31, 0x22, 0x0e, 0x47, 0x61, 0x74, 0x68, 0x65, 0x72, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x09, 0x74,
  0x6f, 0x72, 0x63, 0x68, 0x5f, 0x6a, 0x69, 0x74, 0x5a, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x0b, 0x0a, 0x09, 0x08, 0x01, 0x12, 0x05, 0x0a, 0x03, 0x08, 0x80, 0x03, 0x5a, 0x1f,
  0x0a, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x12, 0x13, 0x0a, 0x11, 0x08, 0x01, 0x12, 0x0d, 0x0a, 0x02, 0x08, 0x30, 0x0a, 0x03, 0x08, 0x80, 0x01, 0x0a, 0x02, 0x08, 0x08, 0x5a,
  0x2c, 0x0a, 0x0a, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x73, 0x12, 0x1e, 0x0a, 0x1c, 0x08, 0x02, 0x12, 0x18, 0x0a, 0x12, 0x12, 0x10, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x69,
  0x6e, 0x67, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x0a, 0x02, 0x08, 0x30, 0x62, 0x29, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x1f, 0x0a, 0x1d, 0x08, 0x01, 0x12, 0x19, 0x0a,
  0x17, 0x12, 0x15, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x6d, 0x5f, 0x30, 0x42, 0x02, 0x10, 0x10


]);

const codebookshape = [codebk.length, codebk[0].length, codebk[0][0].length];
// const pqD = 384;
// const pqM = 48;
// const pqDs = 8;
// const pqK = 128;
const codebkflat = Float32Array.from({length: codebk.length * codebk[0].length * codebk[0][0].length}, (e,i) => codebk[Math.floor(i / codebk[0].length / codebk[0][0].length)][Math.floor(i / codebk[0][0].length) % codebk[0].length][i % codebk[0][0].length])
const codebkT = new Tensor("float32", codebkflat, codebookshape)

const numpyChunkSize = 200000;

async function distTopK(inferenceSession, dists, filterColumn, filterValue, filterZero, filterShim, k) {
  // console.log("trying to distTopk");
  const {output: {data: topk}} = await inferenceSession.run({
    "input": (new Tensor("float32", dists)),
    "filterColumn": (new Tensor("float32", filterColumn)),
    "filterValue": (new Tensor("float32", [filterValue])),
    "filterZero": (new Tensor("float32", [filterZero])),
    "filterShim": (new Tensor("float32", [filterShim])),
    "k": (new Tensor("uint8", [k])),
  });
  return topk;
}

async function queryDist(inferenceSession, query, codebook, codebookShape, embeddings, embeddingTensorShape) {
  // console.log("trying to querydist", {query, codebook, codebookShape, embeddings, embeddingTensorShape});
  const {output: {data: distTile}} = await inferenceSession.run({
    "query": (new Tensor("float32", query)),
    "codebook": (new Tensor("float32", codebook, codebookShape)),
    "embeddings": (new Tensor("uint8", embeddings, embeddingTensorShape)),

  })
  return distTile;
}

async function queryToTiledDist(query, embeddings, pqdistinf, dists, firstLetters, firstLetterInt, filteredtopkinf, k, intermediateValueFn, continueFn, embeddingCounter=0) {
  // compute distances a tile at a time, update in the dists array, compute topk not more frequently than every 30 ms (to avoid excessive screen repainting)
  // on an iphone, distances for 1M embeddings runs in ~100 ms whereas topk for 1M floats runs in ~3ms
  // call a sentinel function to halt processing if the outside state changes (there is probably a better way)
  const chunkSize = 100000;
  let lastPaint = Date.now();
  const maxTick = 30;
  const timingStrings = [];
  // console.log({dists: dists.length, chunkSize, firstLetters: firstLetters.length});
  for(; embeddingCounter<embeddings.length; embeddingCounter++){
    // console.log(`starting embedding ${embeddingCounter}`)
    const {data: embeddingData, offset: embeddingOffset} = embeddings[embeddingCounter];
    for(let i=0; i < (embeddingData.length / codebk.length) && continueFn(); i+=chunkSize) {
      // console.log({i, embeddingDatalength: embeddingData.length, continuefn: continueFn()})
      const startTime = Date.now();
      const startEmbeddingPosition = i * codebk.length;
      const embeddingTileLength = chunkSize * codebk.length;
      const embeddingTensorShape = [chunkSize, codebk.length];
      const embeddingTile = new Uint8Array(embeddingData.buffer, startEmbeddingPosition + embeddingData.byteOffset, embeddingTileLength);
      // console.log({i, startEmbeddingPosition, embeddingTileLength, embeddingTensorShape, workingShape: [embeddings.length / codebk.length, codebk.length], embeddingTile, embeddings});
      const distTile = await queryDist(pqdistinf, query, codebkflat, codebookshape, embeddingTile, embeddingTensorShape);
      // console.log("got dists")
      for(let j=0;j<chunkSize;j++) {
        dists[embeddingOffset+i+j] = distTile[j];
      }
      // console.log("wrote dists");
      const distTime = Date.now();
      timingStrings.push(`${distTime - startTime}`)
      // console.log("2")
      intermediateValueFn({dists, distTime: timingStrings.join(), lastPaint});
      // console.log("1")
      if((i === 0 && embeddingCounter === 0) || (distTime - lastPaint > maxTick)) {
        // console.log("0, or we're over time")
        const topk = await distTopK(filteredtopkinf, dists, firstLetters, firstLetterInt, 0, 1024, k);
        const topktime = Date.now();
        timingStrings.push(`-${topktime-distTime} `);
        intermediateValueFn({topk});
        await (new Promise(r => setTimeout(r,0)));
        lastPaint = Date.now()
      }
    }
  }
  if(continueFn()) {
    const topk = await distTopK(filteredtopkinf, dists, firstLetters, firstLetterInt, 0, 1024, k);
    intermediateValueFn({dists, distTime: timingStrings.join(), topk});
  }
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {query: "where a word means like how it sounds", firstLetter: "", chunkCount: 10, k: 10, embeddings: [], dists: [], firstLetters: []};
  }
  async componentDidMount() {
    let extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
    this.setState({extractor});
    const filteredtopkinf = await InferenceSession.create(filteredtopkasc);
    const pqdistinf = await InferenceSession.create(pqdist, {executionProviders: ['wasm']});
    this.setState({filteredtopkinf, pqdistinf}, () => this.loadEmbeddings(this.state.chunkCount));
  }
  async loadEmbeddings(maxCount) {
    const embeddings = this.state.embeddings.slice(0, maxCount);
    const firstLetters = Float32Array.from({length: maxCount * numpyChunkSize});
    const dists = Float32Array.from({length: firstLetters.length}, () => 1234567890);
    const maxoldlen = Math.min(firstLetters.length, this.state.firstLetters.length);
    for(let i = 0; i < maxoldlen; i++) {
      firstLetters[i] = this.state.firstLetters[i];
      dists[i] = this.state.dists[i];
    }
    this.setState({embeddings, firstLetters, dists, loadingEmbeddings: true});
    for(let i = embeddings.length; i < maxCount; i++) {
      const embeddingShardPath = `./embedding-${i}-shardsize-${numpyChunkSize}.arrow`;
      const titleShardPath = `./title-${i}-shardsize-${numpyChunkSize}.arrow`;
      const eResponse = await fetch(embeddingShardPath);
      const tResponse = await fetch(titleShardPath);
      const eBuffer = await eResponse.arrayBuffer();
      const tBuffer = await tResponse.arrayBuffer();
      const eArrow = tableFromIPC(eBuffer);
      const title = tableFromIPC(tBuffer);
      const data = eArrow.data[0].children[0].values;
      const lastEmbedding = {
        data,
        offset: i * numpyChunkSize,
        title,
      };
      embeddings.push(lastEmbedding);
      for(let j = 0; j < lastEmbedding.data.length / codebk.length; j++) {
        firstLetters[lastEmbedding.offset + j] = lastEmbedding.title.get(j)['title'].charCodeAt(0);
      }
      await this.makeQuery({onlyLast: true, skipEmbed: true});
    }
    this.setState({loadingEmbeddings: false}, () => this.makeQuery({onlyFilter: true}))
  }
  async makeQuery({onlyLast, onlyFilter, skipEmbed}) {
    const {extractor, embeddings, query, queryEmbedding, firstLetters, firstLetter, filteredtopkinf, pqdistinf, dists, k, } = this.state;
    const firstLetterInt = firstLetter.length === 0 ? 0 : firstLetter.charCodeAt(0);
    if(onlyFilter) {
      const startTime = Date.now();
      const topk = await distTopK(filteredtopkinf, dists, firstLetters, firstLetterInt, 0, 1024, k);
      const endTime = Date.now();
      this.setState({topk, distTime: `${endTime - startTime}`, minilmtime: "—"});
      return;
    }
    if(!skipEmbed || !queryEmbedding){
      const minilmstart = Date.now();
      const minilmresult = await extractor(query, {pooling: "mean", normalize: true});
      const minilmend = Date.now();
      this.setState({minilmtime: minilmend - minilmstart, queryEmbedding: minilmresult.data}, () => this.makeQuery({skipEmbed: true}));
      return;
    }
    const embeddingCounter = onlyLast ? (embeddings.length - 1) : 0;
    await queryToTiledDist(queryEmbedding, embeddings, pqdistinf, dists, firstLetters, firstLetterInt, filteredtopkinf, k, (h) => this.setState(h), () => query === this.state.query, embeddingCounter);
  }
  render() {
    const {query, minilmtime, distTime, firstLetter, filteredtopkinf, topk, embeddings, extractor, k, newEmbeddingSliderValue} = this.state;
    if(!extractor) {
      return (<div>Waiting for MiniLM to load</div>);
    }
    if(!filteredtopkinf) {
      return (<div>Waiting for WASM to load</div>)
    }
    if(!embeddings) {
      return (<div>Waiting for the first embedding to load</div>)
    }
    return (<div className="App">
      <h1>Wikipedia search-by-vibes</h1>
      <h2>
        <textarea value={query} placeholder="query to make" onChange={e => this.setState({query: e.target.value}, () => this.makeQuery({}))}></textarea>
        <br/>
        <input type="text" value={firstLetter} placeholder="first letter to filter on"
             onChange={e => this.setState({firstLetter: e.target.value.slice(0,1)}, () => this.makeQuery({onlyFilter: true}))}>
        </input>
        <RangeSlider tooltip='on' tooltipLabel={currentValue => currentValue === 1 ? 'TOP RESULT' : `TOP ${currentValue} RESULTS`} min={1} max={200} value={k} tooltipPlacement={'top'} onChange={e => this.setState({k: e.target.value}, () => this.makeQuery({onlyFilter: true}))} />
        </h2>
      <div className='topk-results'>
        {
          (!topk) ? "Waiting for topk to run once" : [...Int32Array.from(topk, e => Number(e))].filter(idx => idx < embeddings.length * numpyChunkSize).map((idx) => (
          <div className='topk-result' key={`topk${idx}`}>
            <span className='topk-result-title'>{(embeddings[Math.floor(idx / numpyChunkSize)].title).get(idx % numpyChunkSize)['title']}</span>
            <span className='topk-result-rank' title='the rank of the compressed size of the page, 1 is the largest page on Wikipedia'>{millify(idx, {lowercase: true, precision: 0})}</span>
            </div>))
        }
      </div>
      <h4>minilm: {minilmtime} ms <br/> topk: {distTime} ms</h4>
      <h2>
        <RangeSlider tooltip='on' tooltipLabel={currentValue => (this.state.loadingEmbeddings ? "⏳ " : "") + (currentValue === embeddings.length ? `SEARCHING ${embeddings.length * numpyChunkSize / 1000000} MILLION PAGES OFFLINE.` : `LOAD ${currentValue * numpyChunkSize / 1000000} MILLION PAGES`)}
          min={0} max={32} value={newEmbeddingSliderValue || embeddings.length}
          tooltipPlacement='top'
          onChange={e => this.state.loadingEmbeddings ? "" : this.setState({newEmbeddingSliderValue: e.target.value})}
          onAfterChange={e => {if(this.state.loadingEmbeddings) { return; } const newVal = e.target.value; this.setState({newEmbeddingSliderValue: undefined, loadingEmbeddings: true}, () => this.loadEmbeddings(newVal))}}
          />
      </h2>
      <h3 style={ {textAlign: 'right'}} >
         —Lee Butterman, June 2023.<br/><a href="https://leebutterman.com">how this was made ⋙</a>
      </h3>

    </div>);
  }
}

export default App;
