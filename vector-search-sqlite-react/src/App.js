import './App.css';
import React from 'react';
import { tableFromIPC } from 'apache-arrow';
import codebk from './codewords.json';
import { pipeline } from '@xenova/transformers';
import * as ort from 'onnxruntime-web';

const InferenceSession = ort.InferenceSession;
const Tensor = ort.Tensor;

// Add either `filterZero` or `filterShim` to `input`, based on whether the value of `filterColumn` is `filterValue`
const filteredtopkasc = Uint8Array.from([
  0x08, 0x08, 0x12, 0x07, 0x70, 0x79, 0x74, 0x6f, 0x72, 0x63, 0x68, 0x1a, 0x05, 0x32, 0x2e, 0x31, 0x2e, 0x30, 0x3a, 0xde, 0x05, 0x0a, 0x3b, 0x0a, 0x0c, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43,
  0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0f, 0x2f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75,
  0x74, 0x5f, 0x30, 0x1a, 0x06, 0x2f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x22, 0x05, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x0a, 0x49, 0x0a, 0x0f, 0x2f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x5f, 0x6f, 0x75, 0x74,
  0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5a, 0x65, 0x72, 0x6f, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x68, 0x69, 0x6d, 0x12, 0x0f, 0x2f,
  0x57, 0x68, 0x65, 0x72, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x06, 0x2f, 0x57, 0x68, 0x65, 0x72, 0x65, 0x22, 0x05, 0x57, 0x68, 0x65, 0x72, 0x65, 0x0a, 0x32, 0x0a,
  0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x0a, 0x0f, 0x2f, 0x57, 0x68, 0x65, 0x72, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0d, 0x2f, 0x41, 0x64, 0x64, 0x5f, 0x6f, 0x75,
  0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x04, 0x2f, 0x41, 0x64, 0x64, 0x22, 0x03, 0x41, 0x64, 0x64, 0x0a, 0x45, 0x12, 0x12, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x6f,
  0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x09, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a, 0x0a, 0x05,
  0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x4f, 0x0a, 0x01, 0x6b, 0x0a, 0x12, 0x2f,
  0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70,
  0x75, 0x74, 0x5f, 0x30, 0x1a, 0x08, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x22, 0x07, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x2a, 0x10, 0x0a, 0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
  0x7a, 0x65, 0x72, 0x6f, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x0a, 0x3b, 0x0a, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0e,
  0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x05, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x22, 0x04, 0x43, 0x61, 0x73, 0x74, 0x2a, 0x09, 0x0a, 0x02, 0x74,
  0x6f, 0x18, 0x07, 0xa0, 0x01, 0x02, 0x0a, 0x79, 0x0a, 0x0d, 0x2f, 0x41, 0x64, 0x64, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x0e, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f,
  0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0e, 0x2f, 0x54, 0x6f, 0x70, 0x4b, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x1a,
  0x05, 0x2f, 0x54, 0x6f, 0x70, 0x4b, 0x22, 0x04, 0x54, 0x6f, 0x70, 0x4b, 0x2a, 0x14, 0x0a, 0x04, 0x61, 0x78, 0x69, 0x73, 0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xa0,
  0x01, 0x02, 0x2a, 0x0e, 0x0a, 0x07, 0x6c, 0x61, 0x72, 0x67, 0x65, 0x73, 0x74, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x2a, 0x0d, 0x0a, 0x06, 0x73, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x18, 0x01, 0xa0, 0x01,
  0x02, 0x12, 0x09, 0x74, 0x6f, 0x72, 0x63, 0x68, 0x5f, 0x6a, 0x69, 0x74, 0x5a, 0x1b, 0x0a, 0x05, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x12, 0x12, 0x0a, 0x10, 0x08, 0x01, 0x12, 0x0c, 0x0a, 0x0a, 0x12,
  0x08, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6c, 0x65, 0x6e, 0x5a, 0x22, 0x0a, 0x0c, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x12, 0x0a, 0x10, 0x08, 0x01, 0x12,
  0x0c, 0x0a, 0x0a, 0x12, 0x08, 0x61, 0x72, 0x72, 0x61, 0x79, 0x6c, 0x65, 0x6e, 0x5a, 0x19, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0a, 0x0a, 0x08,
  0x08, 0x01, 0x12, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x5a, 0x18, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5a, 0x65, 0x72, 0x6f, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x01, 0x12, 0x04, 0x0a, 0x02,
  0x08, 0x01, 0x5a, 0x18, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x68, 0x69, 0x6d, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x01, 0x12, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x5a, 0x0f, 0x0a, 0x01,
  0x6b, 0x12, 0x0a, 0x0a, 0x08, 0x08, 0x02, 0x12, 0x04, 0x0a, 0x02, 0x08, 0x01, 0x62, 0x24, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x1a, 0x0a, 0x18, 0x08, 0x07, 0x12, 0x14, 0x0a,
  0x12, 0x12, 0x10, 0x54, 0x6f, 0x70, 0x4b, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x6d, 0x5f, 0x30, 0x42, 0x02, 0x10, 0x10

]);

// this is handmade ONNX using GatherElements from a much less efficient PyTorch model. The dimensions for PQ48x7 quantizing a 384-dimensional embedding is baked in.
// thanks, https://github.com/ZhangGe6/onnx-modifier
const pqdist = Uint8Array.from([
  0x08, 0x08, 0x12, 0x07, 0x70, 0x79, 0x74, 0x6f, 0x72, 0x63, 0x68, 0x1a, 0x05, 0x32, 0x2e, 0x31, 0x2e, 0x30, 0x3a, 0xe3, 0x0c, 0x0a, 0x55, 0x12, 0x12, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61,
  0x6e, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x09, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74,
  0x2a, 0x2a, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x1e, 0x08, 0x03, 0x10, 0x07, 0x4a, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x53, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x0a, 0x12, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74,
  0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x08, 0x2f, 0x52,
  0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x22, 0x07, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x2a, 0x10, 0x0a, 0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x7a, 0x65, 0x72, 0x6f, 0x18, 0x00, 0xa0, 0x01,
  0x02, 0x0a, 0x37, 0x0a, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x0a, 0x11, 0x2f, 0x52, 0x65, 0x73, 0x68, 0x61, 0x70, 0x65, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30,
  0x12, 0x0d, 0x2f, 0x53, 0x75, 0x62, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x04, 0x2f, 0x53, 0x75, 0x62, 0x22, 0x03, 0x53, 0x75, 0x62, 0x0a, 0x29, 0x0a, 0x0d, 0x2f, 0x53,
  0x75, 0x62, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0d, 0x2f, 0x41, 0x62, 0x73, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x04, 0x2f, 0x41, 0x62, 0x73,
  0x22, 0x03, 0x41, 0x62, 0x73, 0x0a, 0x43, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x0b, 0x2f,
  0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x08, 0x10,
  0x01, 0x4a, 0x04, 0x00, 0x00, 0x00, 0x40, 0xa0, 0x01, 0x04, 0x0a, 0x3f, 0x0a, 0x0d, 0x2f, 0x41, 0x62, 0x73, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x14, 0x2f, 0x43, 0x6f,
  0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0d, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30,
  0x1a, 0x04, 0x2f, 0x50, 0x6f, 0x77, 0x22, 0x03, 0x50, 0x6f, 0x77, 0x0a, 0x49, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x32, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75,
  0x74, 0x5f, 0x30, 0x1a, 0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x32, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a, 0x0a, 0x05, 0x76, 0x61,
  0x6c, 0x75, 0x65, 0x2a, 0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x7f, 0x0a, 0x0d, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x6f,
  0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x32, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x13, 0x2f,
  0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x0a, 0x2f, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x22, 0x09,
  0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x2a, 0x0f, 0x0a, 0x08, 0x6b, 0x65, 0x65, 0x70, 0x64, 0x69, 0x6d, 0x73, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x2a, 0x1b, 0x0a, 0x14, 0x6e, 0x6f,
  0x6f, 0x70, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x5f, 0x61, 0x78, 0x65, 0x73, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x0a, 0x43, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73,
  0x74, 0x61, 0x6e, 0x74, 0x5f, 0x33, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x33, 0x22, 0x08, 0x43, 0x6f,
  0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x08, 0x10, 0x01, 0x4a, 0x04, 0x00, 0x00, 0x00, 0x3f, 0xa0, 0x01, 0x04, 0x0a, 0x49, 0x0a, 0x13,
  0x2f, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x0a, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x33,
  0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0f, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x31, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x06, 0x2f, 0x50, 0x6f, 0x77,
  0x5f, 0x31, 0x22, 0x03, 0x50, 0x6f, 0x77, 0x0a, 0x49, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x34, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a,
  0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x34, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a,
  0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0x01, 0x04, 0x0a, 0x34, 0x0a, 0x0a, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x73,
  0x12, 0x0e, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x1a, 0x05, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x22, 0x04, 0x43, 0x61, 0x73, 0x74, 0x2a, 0x09, 0x0a,
  0x02, 0x74, 0x6f, 0x18, 0x06, 0xa0, 0x01, 0x02, 0x0a, 0x86, 0x02, 0x12, 0x14, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x35, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f,
  0x30, 0x1a, 0x0b, 0x2f, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x35, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0xd6, 0x01, 0x0a, 0x05, 0x76, 0x61, 0x6c,
  0x75, 0x65, 0x2a, 0xc9, 0x01, 0x08, 0x01, 0x08, 0x30, 0x10, 0x06, 0x4a, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x80, 0x05, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x00, 0x80, 0x06, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x80, 0x09, 0x00, 0x00, 0x00, 0x0a,
  0x00, 0x00, 0x80, 0x0a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x80, 0x0b, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x80, 0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x80, 0x0d, 0x00, 0x00, 0x00, 0x0e,
  0x00, 0x00, 0x80, 0x0e, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00, 0x12,
  0x00, 0x00, 0x80, 0x12, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x80, 0x14, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x80, 0x15, 0x00, 0x00, 0x00, 0x16,
  0x00, 0x00, 0x80, 0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x80, 0x17, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x47, 0x12, 0x12, 0x6f, 0x6e, 0x6e, 0x78, 0x3a, 0x3a, 0x52, 0x65, 0x64, 0x75, 0x63,
  0x65, 0x53, 0x75, 0x6d, 0x5f, 0x32, 0x31, 0x1a, 0x0b, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x5f, 0x31, 0x36, 0x22, 0x08, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x2a, 0x1a,
  0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x2a, 0x0e, 0x08, 0x01, 0x10, 0x07, 0x4a, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x04, 0x0a, 0x57, 0x0a, 0x0f, 0x63, 0x75,
  0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x34, 0x0a, 0x12, 0x6f, 0x6e, 0x6e, 0x78, 0x3a, 0x3a, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x32,
  0x31, 0x12, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x1a, 0x0c, 0x2f, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x5f, 0x31, 0x22, 0x09, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53,
  0x75, 0x6d, 0x2a, 0x0f, 0x0a, 0x08, 0x6b, 0x65, 0x65, 0x70, 0x64, 0x69, 0x6d, 0x73, 0x18, 0x00, 0xa0, 0x01, 0x02, 0x0a, 0x46, 0x0a, 0x0f, 0x2f, 0x50, 0x6f, 0x77, 0x5f, 0x31, 0x5f, 0x6f, 0x75,
  0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0f, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x31, 0x1a, 0x17, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f,
  0x61, 0x64, 0x64, 0x65, 0x64, 0x5f, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x73, 0x65, 0x30, 0x22, 0x09, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x73, 0x65, 0x0a, 0x60, 0x0a, 0x0f, 0x63,
  0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x31, 0x0a, 0x0e, 0x2f, 0x43, 0x61, 0x73, 0x74, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x30, 0x12, 0x0f,
  0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x34, 0x1a, 0x1c, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x61, 0x64, 0x64, 0x65, 0x64, 0x5f, 0x47, 0x61,
  0x74, 0x68, 0x65, 0x72, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x31, 0x22, 0x0e, 0x47, 0x61, 0x74, 0x68, 0x65, 0x72, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x09, 0x74,
  0x6f, 0x72, 0x63, 0x68, 0x5f, 0x6a, 0x69, 0x74, 0x5a, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x0b, 0x0a, 0x09, 0x08, 0x01, 0x12, 0x05, 0x0a, 0x03, 0x08, 0x80, 0x03, 0x5a, 0x1f,
  0x0a, 0x08, 0x63, 0x6f, 0x64, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x12, 0x13, 0x0a, 0x11, 0x08, 0x01, 0x12, 0x0d, 0x0a, 0x02, 0x08, 0x30, 0x0a, 0x03, 0x08, 0x80, 0x01, 0x0a, 0x02, 0x08, 0x08, 0x5a,
  0x2c, 0x0a, 0x0a, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x69, 0x6e, 0x67, 0x73, 0x12, 0x1e, 0x0a, 0x1c, 0x08, 0x02, 0x12, 0x18, 0x0a, 0x12, 0x12, 0x10, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x69,
  0x6e, 0x67, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x0a, 0x02, 0x08, 0x30, 0x62, 0x29, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x12, 0x1f, 0x0a, 0x1d, 0x08, 0x01, 0x12, 0x19, 0x0a,
  0x17, 0x12, 0x15, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x53, 0x75, 0x6d, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x5f, 0x64, 0x69, 0x6d, 0x5f, 0x30, 0x42, 0x02, 0x10, 0x10


]);

const codebookshape = [codebk.length, codebk[0].length, codebk[0][0].length];
// const pqD = 384;
// const pqM = 48;
// const pqDs = 8;
// const pqK = 128;
const codebkflat = Float32Array.from({length: codebk.length * codebk[0].length * codebk[0][0].length}, (e,i) => codebk[Math.floor(i / codebk[0].length / codebk[0][0].length)][Math.floor(i / codebk[0][0].length) % codebk[0].length][i % codebk[0][0].length])
const codebkT = new Tensor("float32", codebkflat, codebookshape)

const numpyChunkSize = 200000;

async function queryToTiledDist(query, embeddings, pqdistinf, dists, firstLetters, firstLetterInt, filteredtopkinf, intermediateValueFn, continueFn) {
  // compute distances a tile at a time, update in the dists array, compute topk not more frequently than every 30 ms (to avoid excessive screen repainting)
  // on an iphone, distances for 1M embeddings runs in ~100 ms whereas topk for 1M floats runs in ~3ms
  // call a sentinel function to halt processing if the outside state changes (there is probably a better way)
  const chunkSize = 100000;
  let lastPaint = Date.now();
  const maxTick = 30;
  const timingStrings = [];
  // console.log({distsLength: dists.length, chunkSize});
  for(let embeddingCounter=0; embeddingCounter<embeddings.length; embeddingCounter++){
    // console.log(`starting embedding ${embeddingCounter}`)
    const {data: embeddingData, offset: embeddingOffset} = embeddings[embeddingCounter];
    for(let i=0; i < (embeddingData.length / codebk.length) && continueFn(); i+=chunkSize) {
      // console.log({i, embeddingDatalength: embeddingData.length, continuefn: continueFn()})
      const startTime = Date.now();
      const startEmbeddingPosition = i * codebk.length;
      const embeddingTileLength = chunkSize * codebk.length;
      const embeddingTensorShape = [chunkSize, codebk.length];
      const embeddingTile = new Uint8Array(embeddingData.buffer, startEmbeddingPosition + embeddingData.byteOffset, embeddingTileLength);
      // console.log({i, startEmbeddingPosition, embeddingTileLength, embeddingTensorShape, workingShape: [embeddings.length / codebk.length, codebk.length], embeddingTile, embeddings});
      const {output: {data: distTile}} = await pqdistinf.run({
        "query": (new Tensor("float32", query)),
        "codebook": codebkT,
        "embeddings": (new Tensor("uint8", embeddingTile, embeddingTensorShape)),
      });
      // console.log("got dists")
      for(let j=0;j<chunkSize;j++) {
        dists[embeddingOffset+i+j] = distTile[j];
      }
      // console.log("wrote dists");
      const distTime = Date.now();
      timingStrings.push(`${distTime - startTime}`)
      // console.log("2")
      intermediateValueFn({dists, distTime: timingStrings.join(), lastPaint});
      // console.log("1")
      if((i === 0 && embeddingCounter === 0) || (distTime - lastPaint > maxTick)) {
        // console.log("0, or we're over time")
        const {output: {data: topk}} = await filteredtopkinf.run({
          "input": (new Tensor("float32", dists)),
          "filterColumn": (new Tensor("float32", firstLetters)),
          "filterValue": (new Tensor("float32", [firstLetterInt])),
          "filterZero": (new Tensor("float32", [0])),
          "filterShim": (new Tensor("float32", [1024])),
          "k": (new Tensor("uint8", [10])),
        })
        const topktime = Date.now();
        timingStrings.push(`_(${topktime-distTime})_`);
        intermediateValueFn({topk});
        await (new Promise(r => setTimeout(r,0)));
        lastPaint = Date.now()
      }
    }
  }
  // console.log("final topk")
  const {output: {data: topk}} = await filteredtopkinf.run({
    "input": (new Tensor("float32", dists)),
    "filterColumn": (new Tensor("float32", firstLetters)),
    "filterValue": (new Tensor("float32", [firstLetterInt])),
    "filterZero": (new Tensor("float32", [0])),
    "filterShim": (new Tensor("float32", [1024])),
    "k": (new Tensor("uint8", [10])),
  })
  return {dists, distTime: timingStrings.join(), topk};
}

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {query: "where a word means like how it sounds", firstLetter: "", chunkCount: 10};
  }
  async componentDidMount() {
    let extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
    this.setState({extractor});
    const filteredtopkinf = await InferenceSession.create(filteredtopkasc);
    const pqdistinf = await InferenceSession.create(pqdist, {executionProviders: ['wasm']});
    this.setState({filteredtopkinf, pqdistinf}, () => this.loadEmbeddings(this.state.chunkCount));
  }
  async loadEmbeddings(maxCount) {
    const embeddings = [];
    const firstLetters = Float32Array.from({length: maxCount * numpyChunkSize});
    const dists = Float32Array.from({length: firstLetters.length}, () => 1234567890);
    this.setState({embeddings, firstLetters, dists});
    for(let i = 0; i < maxCount; i++) {
      const embeddingShardPath = `./embedding-${i}-shardsize-${numpyChunkSize}.arrow`;
      const titleShardPath = `./title-${i}-shardsize-${numpyChunkSize}.arrow`;
      const eResponse = await fetch(embeddingShardPath);
      const tResponse = await fetch(titleShardPath);
      const eBuffer = await eResponse.arrayBuffer();
      const tBuffer = await tResponse.arrayBuffer();
      const eArrow = tableFromIPC(eBuffer);
      const title = tableFromIPC(tBuffer);
      const data = eArrow.data[0].children[0].values;
      const lastEmbedding = {
        data,
        offset: i * numpyChunkSize,
        title,
      };
      embeddings.push(lastEmbedding);
      for(let j = 0; j < lastEmbedding.data.length / codebk.length; j++) {
        firstLetters[lastEmbedding.offset + j] = lastEmbedding.title.get(j)['title'].charCodeAt(0);
      }
      await this.makeQuery();
    }

  }
  async makeQuery() {
    const {extractor, embeddings, query, firstLetters, firstLetter, filteredtopkinf, pqdistinf, dists, } = this.state;
    const firstLetterInt = firstLetter.length === 0 ? 0 : firstLetter.charCodeAt(0);
    const minilmstart = Date.now();
    const minilmresult = await extractor(query, {pooling: "mean", normalize: true});
    const minilmend = Date.now();
    this.setState({minilmtime: minilmend - minilmstart});
    const {distTime, topk} = await queryToTiledDist(minilmresult.data, embeddings, pqdistinf, dists, firstLetters, firstLetterInt, filteredtopkinf, (h) => this.setState(h), () => query === this.state.query);
    this.setState({distTime, topk});
  }
  render() {
    const {query, minilmtime, distTime, firstLetter, filteredtopkinf, topk, embeddings, extractor} = this.state;
    if(!extractor) {
      return (<div>Waiting for MiniLM to load</div>);
    }
    if(!filteredtopkinf) {
      return (<div>Waiting for WASM to load</div>)
    }
    if(!embeddings) {
      return (<div>Waiting for the first embedding to load</div>)
    }
    return (<div className="App">
      <h1>Wikipedia search-by-vibes</h1>
      <h2><textarea value={query} placeholder="query to make" onChange={e => this.setState({query: e.target.value}, () => this.makeQuery())}></textarea><br/>
      <input type="text" value={firstLetter} placeholder="first letter to filter on"
             onChange={e => this.setState({firstLetter: e.target.value.slice(0,1)}, () => this.makeQuery())}></input></h2>
      <div>
        {
          !topk ? "Waiting for topk to run once" : [...Int32Array.from(topk, e => Number(e))].map((idx) => (<div class="" key={`topk${idx}`} title={idx}>{(embeddings[Math.floor(idx / numpyChunkSize)].title).get(idx % numpyChunkSize)['title']}<sup>{`${idx}`}</sup></div>))
        }
      </div>
      <h4>minilm: {minilmtime} ms <br/> topk: {distTime} ms</h4>
      <h3>Searching {`${embeddings.length * numpyChunkSize / 1000000}`}M articles <br/> © Lee Butterman 2023</h3>

    </div>);
  }
}

export default App;
